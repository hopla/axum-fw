<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
	<head>
		<title>DICE Firmware API Documentation</title>
		<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
		<link href="doxygen.css" rel="stylesheet" type="text/css">
	</head>
	<body>
		<table width="100%" border="0" cellspacing="0" cellpadding="0">
			<tr>
				<td><img src="images/tcat.gif" width="399" height="64"></td>
				<td align="right">DICE Firmware</td>
				<td align="right">Compiled on 8 Oct 2009</td>
			</tr>
		</table>
		<hr size="1">
	</body>
</html>
<!-- Generated by Doxygen 1.4.1 -->
<div class="qindex"><a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>Link Abstraction Layer<br>
<small>
[<a class="el" href="group___core.html">Core Modules</a>]</small>
</h1><hr><a name="_details"></a><h2>Detailed Description</h2>
This module provides all necessary interfaces for upper layers to access nodes on the bus and to handle requests from other nodes in any desired 1394 Register Space address range. 
<p>
This module can be used from the command prompt by the cli_lhl and cli_lal commands.<p>
Note: nodeAddr here refers to the devices node address (nodeId | busId) which is a dynamic value arbitrated by each node during bus reset. The value is unique for each bus or bridged network.<p>
<h2>Initialization </h2>
<p>
This module must be initialized once with<p>
<a class="el" href="group___link_abstraction_layer.html#ga8">lalInitialize()</a><p>
After the node has been fully initialized on reset, the function<p>
<a class="el" href="group___link_abstraction_layer.html#ga12">lalForceBusReset()</a><p>
should be called once to cause any other bus nodes to see this node as a fully operational bus node. This is handled in target.c after the main_entry thread is running and has completed all final initializations. <h2>Bus Reset Callbacks </h2>
<p>
Modules that need to be made aware of bus reset activity may install callbacks for bus reset indication and bus reset complete events using<p>
<a class="el" href="group___bus_reset_interface.html#ga1">lalRegisterBRIndicationCallback()</a> <a class="el" href="group___bus_reset_interface.html#ga2">lalRegisterBRCompletionCallback()</a><p>
Indication callbacks are called once a valid bus reset has been detected.<p>
Complete callbacks are called after all bus reset processing is complete, which means the selfId's are verified, maps are completed, bus info blocks have been scanned, handles have been remapped to the correct node addresses, etc.<p>
Note that all general packet queueing is halted until bus reset complete. See the section on Queueing below for details. <h2>Address Range Callbacks </h2>
<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="group___address_range_callback.html">Address Range Callback Management</a> module</dd></dl>
Address Range Callbacks are used when another node issues a request to thisNode in an address range of interest to a module. This is done with<p>
<a class="el" href="group___address_range_callback.html#ga1">lalAddressRangeRegisterCB()</a><p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="group___lock_handler.html">Lock Transaction Handler</a></dd></dl>
Callbacks should not "block" This means that a callback should normally put the packet block in a queue and return immediately and should not wait on any OS resource. This way, the packet is not handled in the thread of the lower layers.<p>
Sparse Ranges Some protocols may be interested in a sparse set of ranges within a larger address range. For efficiency, the module that implements the protocol should allocate the entire range, where the range does not overlap with other module's needs of course. The callback may return an address error (see below) for addresses within the larger range that do not apply. This will cause the transaction layer to return the appropriate confirmation to the requester node.<p>
Callback return codes The callback will be executed when a number of different types of requests happen in the allocated address space. These include read, write and lock requests. The module may handle any of these and shall use the enumerated response types defined by RCODE_1394 for return values. For instance, when the request type is handled and is successful, RESP_COMPLETE is returned. In the case of a sparsely implemented address range, the module may return RESP_ADDRESS_ERROR. In the case where a particular request type is not handled within the range, the module should return RESP_TYPE_ERROR, etc.<p>
<h2>Bus Info and Device Info </h2>
<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="group___info_and_handles.html">Device Information and Handles</a></dd></dl>
Modules that initiate transactions to other nodes need access to information about the current bus topology, such as the number of nodes present, the bus generation, etc, and info about each specific device. Modules will generally initiate transactions with other bus devices via nodeAddr-independent handles, as described below. Handles are created using information discovered using the functions:<p>
<a class="el" href="group___info_and_handles.html#ga0">lalGetBusInfo()</a> this function provides information such as the current number of nodes on the bus, the bus generation (number of bus resets seen by thisNode since reset), thisNode's nodeAddr and the current bus time value.<p>
this is one of the first functions a module may wish to use when finding a target node. this funciton returns information about the bus after the most recent bus reset. the lalInfoBlock structure contains a field which shows the number of nodes on the bus, and a field containing the current busId. a module can then iterate thru the found nodes on the bus given this info, using lalGetDeviceInfo, to determine specific info about each bus node.<p>
<a class="el" href="group___info_and_handles.html#ga1">lalGetDeviceInfo()</a> this function provides information about a specific device by nodeAddr, such as its WWUID and active state.<p>
discover information about a bus device, such as WWUID and active state, in order to create a handle for 1394 i/o. nodeAddr is (busId | nodeID), i.e. node 2 has a node address of 0xffc2. <h2>Handles and Node Addresses </h2>
<p>
As mentioned before, devices are generally accessed by handles. A device's nodeAddr may change after a bus reset, whereas its WWUID will never change. A handle allows access to a node regardless of its nodeAddr. Note that not all devices (such as repeaters, or nodes that are powered off) support the General ROM Format, which specifies a WWUID. Handles may still be opened to such devices, but will be invalidated after each bus reset. Also note that a handle created with a non-compliant device will simply be the nodeAddr of the device. Using a handle for both compliant and non-compliant devices will efficiently let modules know when the nodeAddr is no longer useable as a handle.<p>
<a class="el" href="group___info_and_handles.html#ga2">lalCreateHandle()</a> this function uses a WWUID for handle creation. WWUID can be discovered using lalGetBusInfo and then lalGetDeviceInfo. Note that a node that does not respond to bus info read requests during bus reset processing will not have a WWUID. In this case, the nodeAddress can be used instead of a WWUID to create a handle. This handle will be invalidated after a bus reset.<p>
create a handle to a bus device for read/write/lock access. use lalGetDeviceInfo to determine if the desired WWUID is on the bus. handles created using a WWUID will persist across bus reset, unless the node has left the bus or stops responding. alternately, use 0 for wwuid_hi and the node address for wwuid_lo to create a node_id-based handle. node_id-based handles do not persist across bus reset.<p>
<a class="el" href="group___info_and_handles.html#ga3">lalCloseHandle()</a> this function decrements the instance count for the handle. If the instance count for a handle becomes zero, it is invalidated.<p>
lalGetIDFromHandle() this function provides the current nodeAddr that corresponds to the handle<p>
<a class="el" href="group___info_and_handles.html#ga5">lalGetHandleFromNodeAddr()</a> this function provides a handle, if previously created and valid, for a nodeAddr <h2>1394 I/O </h2>
<p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="group___l_a_l_async.html">Asynchronous Transaction Interface</a> module</dd></dl>
These are the main device access APIs for use by upper layers.<p>
<a class="el" href="group___l_a_l_async.html#ga3">lalRead1394()</a> performs a handle-based read of register space in a target device.<p>
<a class="el" href="group___l_a_l_async.html#ga4">lalWrite1394()</a> performs a handle-based write of register space in a target device.<p>
<a class="el" href="group___l_a_l_async.html#ga5">lalLock1394()</a> performs a handle-based lock of register space in a target device.<p>
<h2>Async Streams </h2>
<p>
<a class="el" href="group___l_a_l_async_stream.html#ga9">lalAsyncStreamSendData()</a> sends a packet as an async stream packet to the given channel<p>
<a class="el" href="group___l_a_l_async_stream.html#ga1">lalAsyncStreamEnable()</a> enables reception of async streams<p>
<a class="el" href="group___l_a_l_async_stream.html#ga2">lalAsyncStreamDisable()</a> disables reception of async streams<p>
<a class="el" href="group___l_a_l_async_stream.html#ga6">lalAsyncStreamRegisterChannelCB()</a> sets a callback for incoming data on the given stream <h2>thisNode (a.k.a. "the local node") </h2>
<p>
thisNode refers to the node that is currently running this software. Some transactions (handle-based or nodeAddr based) are initiated by thisNode to thisNode, such as ConfigROM read, IRM and CMP transactions. Not all register space addresses to thisNode are supported natively by the lower layers. If your module needs access to other areas, this must be specifically implemented. <h2>Miscellaneous </h2>
<p>
<a class="el" href="group___bus_reset_interface.html#ga0">lalGetBusGeneration()</a> this function returns the number of bus resets seen since reset. This value can be used to compare bus generations of packet blocks if desired.<p>
<a class="el" href="group___link_abstraction_layer.html#ga16">lalGetBusID()</a> this function returns the current busId that thisNode resides on. This will usually be 0xffc0, the "local bus," unless the node is in a bridged environment.<p>
<a class="el" href="group___info_and_handles.html#ga15">lalIsThisNodeAddr()</a> <a class="el" href="group___info_and_handles.html#ga17">lalGetThisNodeAddr()</a> <a class="el" href="group___info_and_handles.html#ga18">lalGetThisHandle()</a> returns the current nodeAddr, handle of the node this software is running on.<p>
lalGetIRMNodeAddr() lalGetIRMHandle() returns the current nodeAddr, handle of the Isochronous Resource Manager.<p>
<a class="el" href="group___link_abstraction_layer.html#ga15">lalGetCycleTime()</a> returns a snapshot of the bus cycle time value at/near the time the function was called.<p>
<h2>Queueing </h2>
<p>
During bus reset, the lower layers must do some housekeeping in order to maintain device handles and allocated bus resources before the upper layer messaging can continue. The lower layers use NORMAL and IMMEDIATE queueing to accomplish this. In almost all cases, modules that use this API will use normal queuing. An example exception is a module that implements CMP. This module must reallocate Isochronous resources in a fixed amount of time, and can perform this with nodeAddr based transactions and therefore does not need to wait for the bus reset to be fully complete to do its tasks. These modules can directly call the IMMEDIATE queueing API's in the LHL. In all other cases, use handle based 1394 I/O API's. <h2>Tools </h2>
<p>
A number of CLI tools are provided for excercizing the LAL APIs. See the following at the command prompt for more info.<p>
<ul>
<li>hdlGBI - get bus info</li><li>hdlGNI - get node info based on nodeAddr</li><li>hdlCreate - create a handle based on WWUID</li><li>hdlClose - close a handle</li><li>hdlDump - show all handles</li><li>read1394 - perform a blocking read</li><li>write1394 - perform a blocking write</li><li>lock1394 - perform a blocking lock</li></ul>

<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Modules</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___bus_reset_interface.html">Bus Reset Interface</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Modules that need to be made aware of bus reset activity may install callbacks for bus reset indication and bus reset complete events using. <br></td></tr>

<p>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___info_and_handles.html">Device Information and Handles</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Devices are generally accessed by handles. <br></td></tr>

<p>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___address_range_callback.html">Address Range Callback Management</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Address Range Callbacks are used when another node issues a request to thisNode in an address range of interest to a module. <br></td></tr>

<p>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___l_a_l_async.html">Asynchronous Transaction Interface</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This modules provides the interface for blocking asynchronous transactions. <br></td></tr>

<p>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___l_a_l_async_stream.html">Asynchronous Stream Interface</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This modules provides the interface for asychronous streams. <br></td></tr>

<p>
<tr><td colspan="2"><br><h2>Data Structures</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><b>LAL_ADDR_DISPATCH_LIST</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_l_a_l___a_d_d_r___r_a_n_g_e.html">LAL_ADDR_RANGE</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">LAL address range.  <a href="struct_l_a_l___a_d_d_r___r_a_n_g_e.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_l_a_l___b_u_s___r_e_s_e_t___i_n_f_o.html">LAL_BUS_RESET_INFO</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">LAL bus reset information.  <a href="struct_l_a_l___b_u_s___r_e_s_e_t___i_n_f_o.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_l_a_l___d_e_v_i_c_e___i_n_f_o.html">LAL_DEVICE_INFO</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">LAL device information.  <a href="struct_l_a_l___d_e_v_i_c_e___i_n_f_o.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><b>LAL_STREAM_DISPATCH_LIST</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><b>LAL_STREAM_DISPATCH_LIST</b></td></tr>

<tr><td colspan="2"><br><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef HRESULT(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___link_abstraction_layer.html#ga2">LAL_CALLBACK</a> )(PB *)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The function type for LAL callbacks (address ranges or asynchronous streams).  <a href="#ga2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef uint32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___link_abstraction_layer.html#ga0">LAL_NODE_HANDLE</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Used for 1394 i/o to devices, persistent across bus reset for compliant devices (i.e.  <a href="#ga0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___link_abstraction_layer.html#ga1">lalBusResetCB</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The function type for bus reset callbacks.  <a href="#ga1"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Enumerations</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___link_abstraction_layer.html#ga30">LAL_SPEED</a> </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The LAL speed codes.  <a href="group___link_abstraction_layer.html#ga30">More...</a><br></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">_TC_INLINE HRESULT&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___link_abstraction_layer.html#ga12">lalForceBusReset</a> (void) _TC_INLINE_ALWAYS</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cause a bus reset, used to announce the node on the bus after boot/inits.  <a href="#ga12"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">_TC_INLINE HRESULT&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___link_abstraction_layer.html#ga13">lalForceRoot</a> (void) _TC_INLINE_ALWAYS</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Delay sending of self-ID packets to force this node to be root.  <a href="#ga13"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">_TC_INLINE HRESULT&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___link_abstraction_layer.html#ga16">lalGetBusID</a> (uint16 *pBusId) _TC_INLINE_ALWAYS</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtain the current bus ID.  <a href="#ga16"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">_TC_INLINE HRESULT&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___link_abstraction_layer.html#ga15">lalGetCycleTime</a> (uint32 *pCycleTime) _TC_INLINE_ALWAYS</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtain the current cycle time.  <a href="#ga15"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">HRESULT&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___link_abstraction_layer.html#ga23">lalGetHandleIRM</a> (<a class="el" href="group___link_abstraction_layer.html#ga0">LAL_NODE_HANDLE</a> *pHandle)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtain the handle for the IRM.  <a href="#ga23"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">_TC_INLINE HRESULT&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___link_abstraction_layer.html#ga22">lalGetNodeAddrIRM</a> (uint32 *pNodeAddr) _TC_INLINE_ALWAYS</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Obtain the node address of the IRM.  <a href="#ga22"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">HRESULT&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___link_abstraction_layer.html#ga8">lalInitialize</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">initialization of this module  <a href="#ga8"></a><br></td></tr>
</table>
<hr><h2>Typedef Documentation</h2>
<a class="anchor" name="ga0" doxytag="lalDefs.h::LAL_NODE_HANDLE"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">typedef uint32 <a class="el" href="group___link_abstraction_layer.html#ga0">LAL_NODE_HANDLE</a>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Used for 1394 i/o to devices, persistent across bus reset for compliant devices (i.e. 
<p>
have General Config ROM format)     </td>
  </tr>
</table>
<a class="anchor" name="ga1" doxytag="lalDefs.h::lalBusResetCB"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">typedef void <a class="el" href="group___link_abstraction_layer.html#ga1">lalBusResetCB</a>(void)          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
The function type for bus reset callbacks. 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="ga2" doxytag="lalDefs.h::LAL_CALLBACK"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">typedef HRESULT(* <a class="el" href="group___link_abstraction_layer.html#ga2">LAL_CALLBACK</a>)(PB *)          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
The function type for LAL callbacks (address ranges or asynchronous streams). 
<p>
    </td>
  </tr>
</table>
<hr><h2>Enumeration Type Documentation</h2>
<a class="anchor" name="ga30" doxytag="lalDefs.h::LAL_SPEED"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">enum <a class="el" href="group___link_abstraction_layer.html#ga30">LAL_SPEED</a>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
The LAL speed codes. 
<p>
    </td>
  </tr>
</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="ga8" doxytag="lal.h::lalInitialize"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">HRESULT lalInitialize           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
initialization of this module 
<p>
    </td>
  </tr>
</table>
<a class="anchor" name="ga12" doxytag="lal.h::lalForceBusReset"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">_TC_INLINE HRESULT lalForceBusReset           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Cause a bus reset, used to announce the node on the bus after boot/inits. 
<p>
<dl compact><dt><b>Returns:</b></dt><dd>NO_ERROR (0) or an <a class="el" href="errorcodes.html">error code</a>. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga13" doxytag="lal.h::lalForceRoot"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">_TC_INLINE HRESULT lalForceRoot           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Delay sending of self-ID packets to force this node to be root. 
<p>
<dl compact><dt><b>Returns:</b></dt><dd>NO_ERROR (0) or an <a class="el" href="errorcodes.html">error code</a>. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga15" doxytag="lal.h::lalGetCycleTime"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">_TC_INLINE HRESULT lalGetCycleTime           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">uint32 *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>pCycleTime</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Obtain the current cycle time. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pCycleTime</em>&nbsp;</td><td>The address of the location to place the current cycle time in. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>NO_ERROR (0) or an <a class="el" href="errorcodes.html">error code</a>. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga16" doxytag="lal.h::lalGetBusID"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">_TC_INLINE HRESULT lalGetBusID           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">uint16 *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>pBusId</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Obtain the current bus ID. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pBusId</em>&nbsp;</td><td>The address to place the current busID in. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>NO_ERROR (0) or an <a class="el" href="errorcodes.html">error code</a>. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga22" doxytag="lal.h::lalGetNodeAddrIRM"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">_TC_INLINE HRESULT lalGetNodeAddrIRM           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">uint32 *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>pNodeAddr</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Obtain the node address of the IRM. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pNodeAddr</em>&nbsp;</td><td>The address to place the node address in of the IRM </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>NO_ERROR (0) or an <a class="el" href="errorcodes.html">error code</a>. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga23" doxytag="lal.h::lalGetHandleIRM"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">HRESULT lalGetHandleIRM           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="group___link_abstraction_layer.html#ga0">LAL_NODE_HANDLE</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>pHandle</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Obtain the handle for the IRM. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pHandle</em>&nbsp;</td><td>The address to place the handle for the IRM </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>NO_ERROR (0) or an <a class="el" href="errorcodes.html">error code</a>. </dd></dl>
    </td>
  </tr>
</table>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
	<head>
		<title>Untitled Document</title>
		<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
		<link href="doxygen.css" rel="stylesheet" type="text/css">
	</head>
	<body>
		<hr size="1">
		<small>This confidential and proprietary software may be used only as authorised by 
			a licensing agreement from TC Applied Technologies, Ltd.
			<p>
			(C) COPYRIGHT 2007 TC Applied Technologies, Ltd. (ALL RIGHTS RESERVED) 
			Unauthorized use, duplication or distribution of this software is strictly 
			prohibited by law. </small></P>
	</body>
</html>
