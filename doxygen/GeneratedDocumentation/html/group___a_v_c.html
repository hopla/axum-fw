<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
	<head>
		<title>DICE Firmware API Documentation</title>
		<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
		<link href="doxygen.css" rel="stylesheet" type="text/css">
	</head>
	<body>
		<table width="100%" border="0" cellspacing="0" cellpadding="0">
			<tr>
				<td><img src="images/tcat.gif" width="399" height="64"></td>
				<td align="right">DICE Firmware</td>
				<td align="right">Compiled on 8 Oct 2009</td>
			</tr>
		</table>
		<hr size="1">
	</body>
</html>
<!-- Generated by Doxygen 1.4.1 -->
<div class="qindex"><a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>AV/C Handling<br>
<small>
[<a class="el" href="group___application.html">Application Building Blocks</a>]</small>
</h1><hr><a name="_details"></a><h2>Detailed Description</h2>
Interfaces the AVC layer to the FCP layer and provides an interface for subunits to use. 
<p>
This module can be used from the command prompt by the cli_avc commands.<p>
Receive packets: Handler dispatches the packet via callbacks registered for subunit type and id. If no callback is registered for the packet's subunit type and ID, this handler sends the 'not implemented' response.<p>
Transmit packets: Handler sends the packet to the appropriate FCP destination address, depending on whether the packet is a COMMAND or RESPONSE packet.<p>
The file /1394AVC/avcDefs.h contains most AV/C definitions.<p>
<h2>Subunit Callbacks </h2>
<p>
AV/C subunits must use the <a class="el" href="group___callback_registry.html">CallbackRegistry</a> to register with this AV/C module using the function <a class="el" href="group___callback_registry.html#ga4">crAddCallback()</a><p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="group___callback_registry.html">CallbackRegistry</a></dd></dl>
The following are example registry descriptors which describe an AV/C Subunit Callback.<p>
<div class="fragment"><pre class="fragment">        CALLBACK_REGISTRY       AVC_CD_PLAYER_CALLBACK[]=
        {
                {CALLBACK_DESCRIPTOR_TYPE,AVC_SUBUNIT_TYPE},
                {CALLBACK_DESCRIPTOR_NEXT,0},
                {AVC_SUBUNIT_CALLBACK_KEY,(uint32)xxx}, <span class="comment">// CALLBACK PTR of TYPE AVC_SUBUNIT_CALLBACK},</span>
                {AVC_SUBUNIT_SUBUNITTYPE_KEY,AVC_SU_TYPE_AV_DISC},
                {KV_TERMINATEKEY,KV_TERMINATEVALUE}
        };
</pre></div><p>
This example describes a callback for AVC_SECURITY functions.<p>
<div class="fragment"><pre class="fragment">        CALLBACK_REGISTRY       AVC_AKE_SECURITY_CALLBACK[]=
        {
                {CALLBACK_DESCRIPTOR_TYPE,AVC_SECURITY_TYPE},
                {CALLBACK_DESCRIPTOR_NEXT,0},
                {AVC_SECURITY_CALLBACK_KEY,(uint32)xxx}, <span class="comment">// CALLBACK PTR of TYPE AVC_SECURITY_CALLBACK},</span>
                {AVC_SECURITY_CATEGORY_KEY,AKE_TYPE_5C},
                {KV_TERMINATEKEY,KV_TERMINATEVALUE}
        };
</pre></div><p>
The AV/C receive packet callback is called when the handler receives an av/c packet for the specified subunit type and id.<p>
Callback functions must have the following format:<p>
<div class="fragment"><pre class="fragment">        HRESULT avcCallback(AVC_HEADER *pHeader, PB *packetBlock)
</pre></div><p>
Parameters: pHeader Structure containing the avc header information extracted from the packet block. packetBlock Pointer to the packet block. Inside the packet block is the AVC datastream which has been opened and its current context is that returned by the DecodeAVCPayloadHeader function.<p>
Note that header info is passed by value rather than by reference. This is to avoid persistence problems when the subunit process runs as its own thread.<p>
The callback function can return the following values:<p>
NO_ERROR Command is supported and response has/will be sent to controller. Subunit will handle memory deallocation of packet block. For all other return values, the subunit must not alter the packet block.<p>
E_PKT_AVC_ACCEPTED Packet was accepted and requested action is expected to complete without failure. The avc handler will send an ACCEPTED response frame and free the packet block. For STATUS ctypes, the callback function may first perform the necessary writes on the packet block payload before returning.<p>
E_PKT_AVC_INTERIM Receiving subunit cannot determine response at this time. Receiving subunit will ensure that a final response is sent. Note the difference between this and SUBUNIT_BUSY. AVC handler will send an INTERIM response.<p>
E_PKT_AVC_IMPLEMENTED Inquiry CTYPE only: opcode is supported. This AVC command handler will send the appropriate response and be responsible for freeing the packet block.<p>
E_PKT_AVC_SUBUNIT_BUSY Subunit could not handle the packet. The buck has been passed back to the avc handler, both to respond (or not) and to free the packetBlock. A subunit implemented as a seprate thread could return this value if the thread's queue is full.<p>
The AV/C command handler will take the appropriate action. There are various actions the avc handler could take:<ul>
<li>send an interim response and keep trying the callback</li><li>ignore the command and dump the packet block.</li><li>send a 'rejected' response</li></ul>
<p>
E_PKT_AVC_NOT_IMPLEMENTED The command is not implemented. Command handler returns the appropriate response and will be responsible for freeing the packetBlock.<p>
Note that the subunit may directly return the AVC response of NOT_IMPLEMENTED to the controller, and the callback functions would return with NO_ERROR.<p>
E_PKT_AVC_REJECTED The command is implemented, but subunit state prevents it from being executed at this time. Command handler will send a 'rejected' response and be responsible for freeing the packetBlock.<p>
Note that the subunit may directly return the AVC response of REJECTED to the controller, and the callback functions would return with NO_ERROR.<p>
It is the responsibility of callback functions to ensure that either the function returns with a non-NO_ERROR value, or a response is sent to the requesting node, within 100ms.<p>
PacketBlock disposal, to summarize: if the subunit callback returns NO_ERROR, the subunit is responsible for disposing the packetBlock. if the subunit callback returns anything else, the handler is responsible for disposing the packetBlock.<p>
<h2>Subunit algorithms </h2>
<p>
The following suggests algorithms for implementing av/c unit and subunit module which use this handler.<p>
AV/C Command type support in subunit implementations:<p>
All subunits MUST support SPECIFIC_INQUIRY and GENERAL_INQUIRY. CONTROL, STATUS, and NOTIFY are supported as per subunit requirements.<p>
A suggested algorithm for a subunit callback function is described below <div class="fragment"><pre class="fragment">        HRESULT subunitCallback(..........)
        {
                <span class="keywordflow">switch</span> (ctype)
                {
                        <span class="keywordflow">case</span> (ctype == AVC_CONTROL) :
                                {       parse data
                                        <span class="keywordflow">if</span> command implemented
                                        {
                                                <a class="code" href="group___a_v_c.html#ga0">avcSendRequest</a>(AVC_ACCEPTED,packetBlock)
                                                send command to host
                                                return NO_ERROR;
                                        }
                                        else
                                        {
                                                <a class="code" href="group___a_v_c.html#ga0">avcSendRequest</a>(AVC_NOT_IMPLEMENTED,packetBlock)
                                                return NO_ERROR;
                                        }
                                }
                        case (ctype == AVC_GENERAL_INQUIRY)  ........                                                   
                                                                                                
                        case (ctype == AVC_SPECIFIC_INQUIRY) ........

                        ...

                        default: return FW_PKT_AVC_NOT_IMPLEMENTED;
                }
                etc
                @code
                
                        A suggested rough algorith for a threaded subunit implementation callback is described below

                        subunitQ is the queue that the subunit receives on.
                @code

                HRESULT subunitCallback(.....)
                {
                        HRESULT hResult;

                        hResult = ( put packetBlock into thread queue )
                        <span class="keywordflow">if</span> (hResult != NO_ERROR)
                        {
                                <span class="keywordflow">if</span> (hResult == TX_QUEUE_FULL) 
                                {
                                        <span class="keywordflow">return</span> FW_PKT_AVC_SUBUNIT_BUSY;
                                }
                                sysLogError( problem with queue )
                        }
                        <span class="keywordflow">return</span> NO_ERROR;
                }
</pre></div><p>
A suggested algorithm for the subunit thread is described below:<p>
<div class="fragment"><pre class="fragment">                HRESULT subunitThreadEntryPoint()
                {
                        .
                        .
                        ( get packet from the queue )
                        <span class="keywordflow">switch</span> (ctype)
                        {
                                <span class="keywordflow">case</span> (ctype == AVC_CONTROL) :
                                        {       parse data
                                                <span class="keywordflow">if</span> command implemented
                                                {
                                                        send command to host
                                                        <a class="code" href="group___a_v_c.html#ga0">avcSendRequest</a>(AVC_ACCEPTED,packetBlock)
                                                }
                                                <span class="keywordflow">else</span>
                                                {
                                                        <a class="code" href="group___a_v_c.html#ga0">avcSendRequest</a>(AVC_NOT_IMPLEMENTED,packetBlock)
                                                }
                                        }
                                <span class="keywordflow">case</span> (ctype == AVC_GENERAL_INQUIRY)  ........                                                   
                                                                                                
                                <span class="keywordflow">case</span> (ctype == AVC_SPECIFIC_INQUIRY) ........

                                <span class="keywordflow">default</span>: {
                                                <a class="code" href="group___a_v_c.html#ga0">avcSendRequest</a>(AVC_NOT_IMPLEMENTED,packetBlock)
                                                 }      
                                }
                                etc
</pre></div><p>
Note: In above algorithms, the packet block must be released if any of the avcSendRequest function calls fail. If re-using the command packet for the response, you must also put your own callback into the 'packet owner callback' field of the packetBlock.<p>
<h2>Subunit Packet Parsing </h2>
<p>
Subunit implementations can use the <a class="el" href="struct_data_stream.html">DataStream</a> utility to parse received packets. This <a class="el" href="struct_data_stream.html">DataStream</a> nodule allows for tightly packed fields to be easily extracted.<p>
The data stream in a received packet block can be obtained by calling:<p>
<a class="el" href="group___packet_blocks.html#ga21">pbGetApplicationDatastream()</a><p>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="group___packet_blocks.html">Packet Blocks</a> <p>
<a class="el" href="group___data_streams.html">Data Stream Parsing</a> <p>
<a class="el" href="group___callback_registry.html">CallbackRegistry</a></dd></dl>

<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">HRESULT&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_v_c.html#ga2">avcCreateResponsePacket</a> (PB *packetBlock, PB **respPacket, BOOL bNewPayloadSize, uint32 payloadSize)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a response packet to send.  <a href="#ga2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">HRESULT&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_v_c.html#ga0">avcSendRequest</a> (uint32 ctype, PB *packetBlock)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sends a packet to the appropriate destination FCP register, depending on command type.  <a href="#ga0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">HRESULT&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_v_c.html#ga1">avcSendResponsePacket</a> (uint32 response, PB *packetBlock)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This is similar to avsSendRequest() with the exception that the response code is written into the packet block before the response is sent.  <a href="#ga1"></a><br></td></tr>
</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="ga0" doxytag="avc.h::avcSendRequest"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">HRESULT avcSendRequest           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">uint32&nbsp;</td>
          <td class="mdname" nowrap> <em>ctype</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>PB *&nbsp;</td>
          <td class="mdname" nowrap> <em>packetBlock</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Sends a packet to the appropriate destination FCP register, depending on command type. 
<p>
Will call tranport layer to send the FCP frame.<p>
Command codes are sent to the FCP_COMMAND_REGISTER Response codes are sent to the FCP_RESPONSE_REGISTER<p>
Before calling avcSendRequest, the caller must:<ul>
<li>fill out the avc header portion of the packet itself - specifically, the subunit type and Id fields (with extensions if any). Note that this will already be done if you re-use the command packet for the response</li><li>fill out the ownerCallback field. This is done for you if you create a new packet. If you are re-using a command packet for the response, you need to explicitly fill in the callback.</li></ul>
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ctype</em>&nbsp;</td><td>One of the AV/C command or response values (see <a class="el" href="avc_defs_8h.html">avcDefs.h</a>) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>packetBlock</em>&nbsp;</td><td>Pointer to the packet block</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>NO_ERROR if successful, IE packet has been given to the FCP layer. When packet has finished moving through the layers, the ownerCallback is called - this would usually be the one that called this avcSendRequest. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga1" doxytag="avc.h::avcSendResponsePacket"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">HRESULT avcSendResponsePacket           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">uint32&nbsp;</td>
          <td class="mdname" nowrap> <em>response</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>PB *&nbsp;</td>
          <td class="mdname" nowrap> <em>packetBlock</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This is similar to avsSendRequest() with the exception that the response code is written into the packet block before the response is sent. 
<p>
Refer to avsSendRequest() <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>response</em>&nbsp;</td><td>One of the AV/C response values (see <a class="el" href="avc_defs_8h.html">avcDefs.h</a>) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>packetBlock</em>&nbsp;</td><td>Pointer to the packet block</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>NO_ERROR if successful, IE packet has been given to the FCP layer. When packet has finished moving through the layers, the ownerCallback is called - this would usually be the one that called this avcSendRequest. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga2" doxytag="avc.h::avcCreateResponsePacket"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">HRESULT avcCreateResponsePacket           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">PB *&nbsp;</td>
          <td class="mdname" nowrap> <em>packetBlock</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>PB **&nbsp;</td>
          <td class="mdname" nowrap> <em>respPacket</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>BOOL&nbsp;</td>
          <td class="mdname" nowrap> <em>bNewPayloadSize</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>uint32&nbsp;</td>
          <td class="mdname" nowrap> <em>payloadSize</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a response packet to send. 
<p>
The source and destination addresses are swapped. This is commonly used by AVC_CTYPE_STATUS responses. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>packetBlock</em>&nbsp;</td><td>The original packet block </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>respPacket</em>&nbsp;</td><td>Address of pointer that will be set to new response packet block. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bNewPayloadSize</em>&nbsp;</td><td>TRUE if the size of the payload is to be changed. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>payloadSize</em>&nbsp;</td><td>The size of the new payload (if bNewPayloadSize == TRUE) </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>NO_ERROR (0) if successful. </dd></dl>
    </td>
  </tr>
</table>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
	<head>
		<title>Untitled Document</title>
		<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
		<link href="doxygen.css" rel="stylesheet" type="text/css">
	</head>
	<body>
		<hr size="1">
		<small>This confidential and proprietary software may be used only as authorised by 
			a licensing agreement from TC Applied Technologies, Ltd.
			<p>
			(C) COPYRIGHT 2007 TC Applied Technologies, Ltd. (ALL RIGHTS RESERVED) 
			Unauthorized use, duplication or distribution of this software is strictly 
			prohibited by law. </small></P>
	</body>
</html>
